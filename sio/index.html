<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">

  <!--
   デフォルトのスタイル
   より見やすく変更しても良い
  -->
  <link rel="stylesheet" href="default.css"/>

  <!--
    SyntaxHighlighter 3.0.83 (http://alexgorbatchev.com/SyntaxHighlighter/)
    Java のコードを読みやすくする
  -->
  <link rel="stylesheet" href="shCore.css"/>
  <link rel="stylesheet" href="shThemeDjango.css"/>
  <script src="shCore.js"></script>
  <script src="shBrushJava.js"></script>
  <script>SyntaxHighlighter.all();</script>

  <!--
    目次を動的に生成する
  -->
  <script src="outliner.js"></script>
  <script>
    window.addEventListener('load', function() {
      // 第一引数: アウトライン対象の要素のセレクタ，第二引数: アウトラインを格納する要素のセレクタ．
      new TOutliner('h2', '#outline');
    });
  </script>

  <title>知能プログラミング演習II レポート</title>
</head>

<body>
<header>
  <!-- グループ番号・学籍番号・名前を書く．-->
  <h1>グループ1 27115069 塩谷昂平</h1>

  <!-- 目次生成用 -->
  <nav id="outline"></nav>
</header>

<h2>グループ</h2>
グループ作成書類: <a href="../GrepX/index.html">Grep6</a><br> 
<ul>
<li>塩谷昂平 27115069: 課題6-1 考察担当
<li><a href="../../../../ckb15999/workspace/kprep/repX/index.html">
</ul>

<hr>

<h2>課題6-1</h2>
<!-- 課題を書く．-->
まず，教科書3.2.1の「前向き推論」のプログラムと教科書3.2.2の「後向き推論」のプログラムとの動作確認をし， 前向き推論と後ろ向き推論の違いを説明せよ．また，実行例を示してルールが選択される過程を説明せよ． 

<br>
<br>
<p>
前向き推論は、最初に与えられた仮定群を元にruleを読み出しif条件にマッチすれば新しいアサーションを仮定群に追加していき、全てのruleを一通り読み出し終えたら最初の仮定群とrule条件にマッチしたことで新しく作成されたアサーションをワーキングメモリーに書き出す。

この一連の流れを新しいアサーションが生成されなくなるまで繰り返すことで、ワーキングメモリーに必要な応答が書き出される。</p>
<img src="./forward.png"/>

<p>後ろ向き推論は、ある結論の仮定が先に与えられ、それが成立するためのruleを繰り返し読み出して後件と事実とのマッチを検討する。必要なルールを呼びだし終えたとき、最初の仮定に対しての応答が与えられる。</p>
<img src="./backward.png">


</p>

<!-- 画像ファイルを貼る場合は <img> タグを使う -->
<!--<img src="./hoge/image.png"/> -->


<h2>考察</h2>
<p>
前向き推論は、与えられた条件に合致すれば新しい情報を得ることができ、またそれを元にして新しい情報を次々に得ていくという意味で人間の行う推論方法に近く、感覚的に捉えやすい。
ルールの設定に関しては上から順番に全てのルールを読み出していくので、確実性がある。ただし、プログラムの性質上最終的に書き出されるのは一つの応答ではなくワーキングメモリーの情報群となり、必要な情報が書き出されているかどうかは人間が確認する必要がある。</p>
<p>
後ろ向き推論は、最初に与えられた結論が正しいかどうかをルールを用いて補強していく、人間が普段用いないコンピュータ的な推論方法といえる。
ルールの設定に関しては、与えられた仮定を満たすために必要なルールを逐次読み出す。そのルールの中に、直接の条件として与えられてはいないがそのルールを満たすためのルールが存在していればそれも読み出していく。しかし、このようなルールの入れ子を辿る途中で満たすことのできない条件に当たってしまった場合、そこまでの探索は無意味なものとなってしまい、また最初に戻って必要なルールを再検索するという挙動をするため、もしルールがもっと多く網目状に入り組んでいるような場合、計算時間の安定性に欠けるように感じた。
反面、探索に成功し全ての条件が一致した場合、プログラムの最後には応答が一つだけ書き出され、簡潔で分かりやすい。
どちらも一長一短であることが理解できた。
</p>

<!--
 考察を書く．PNGやGIF等の絵を張っても良い．
 例: 自分で工夫して解決した点，その解決手法，なぜそうしたのか，その手法の素晴らしさ，上手くいかなかった点，なぜ上手くいかなかったのか，など．
 例: 今回はできなかったが，更に〜の機能を追加すべきである．なぜなら，...
-->
<p>

</p>


<hr>


<h2>感想</h2>
<!-- 感想を書く．-->
<!-- 例: 〜が面白かった，〜がわからなかった，〜を作ってみたい，講義・演習に関する要望，など．-->
<p>



<h2>参考文献</h2>
<!-- 参考文献を書く．助けてもらった人がいれば，それも書く-->

