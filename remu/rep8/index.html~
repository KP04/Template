<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">

  <!--
   デフォルトのスタイル
   より見やすく変更しても良い
  -->
  <link rel="stylesheet" href="default.css"/>

  <!--
    SyntaxHighlighter 3.0.83 (http://alexgorbatchev.com/SyntaxHighlighter/)
    Java のコードを読みやすくする
  -->
  <link rel="stylesheet" href="shCore.css"/>
  <link rel="stylesheet" href="shThemeDjango.css"/>
  <script src="shCore.js"></script>
  <script src="shBrushJava.js"></script>
  <script>SyntaxHighlighter.all();</script>

  <!--
    目次を動的に生成する
  -->
  <script src="outliner.js"></script>
  <script>
    window.addEventListener('load', function() {
      // 第一引数: アウトライン対象の要素のセレクタ，第二引数: アウトラインを格納する要素のセレクタ．
      new TOutliner('h2', '#outline');
    });
  </script>

  <title>知能プログラミング演習II レポート</title>
</head>

<body>
<header>
  <!-- グループ番号・学籍番号・名前を書く．-->
  <h1>グループ4 27115126 長谷川達也</h1>

  <!-- 目次生成用 -->
  <nav id="outline"></nav>
</header>

<h2>グループ</h2>
<ol>
グループ作成書類: <a href="../Grep8/index.html">Grep8</a><br>
メンバーと役割分担: 
<ul>
<li><a href="../../../../ckb15999/workspace/kprep/repX/index.html">佐藤 嵩晟 27115064</a>
: GUI作成担当
<li><a href="../../../../ckb15999/workspace/kprep/repX/index.html">塩谷 昂平 27115069</a>
: スライド作成担当
<li><a href="../../../../ckb15999/workspace/kprep/repX/index.html">長谷川 達也 27115126</a>
: プランニング拡張担当
<li><a href="../../../../ckb15999/workspace/kprep/repX/index.html">瀬戸口 大貴 27115085</a>
: プランニング拡張担当
</ul>
</ol>

<h2>ソースファイル</h2>
<ul>
  <li><a href="./Planing/src/Planner.java">Planner.java</a>
    <!-- 実装・変更したソースファイルへのリンク．修正する． -->
    <!-- ※ リンクは絶対パスに変更せず，上記のような相対パスのままで！ -->
</ul>

<hr>

<!-- ------------------------------------------------------------------------------------------------------------------- -->

<h2>課題8-1</h2>
<!-- 課題を書く．-->
<ol>
グループで話し合ってどのプログラムを拡張するか決め，自由に拡張した上で，最終発表のデモシナリオを決めよ．<br>
課題6, 7の発展課題を参考にして拡張しても良いし，全く新しい独自仕様を考案しても構わない．<br>
</ol>


<h3>プログラムの構造</h3>
<!--  どのような設計をしたか．-->
<ul>
  今回の課題で使用したプログラムは、課題７で用いたものを競合戦略がさらに改善できるようにチューニングしたものである。
基本的なプログラムの流れ(再帰処理で実現している点)は変えなかったが、最善なオペレータが選ばれやすいような状況の設定
が出来るようなプログラムになるように心がけて作成した。<br><br>
具体的には
<ol>

<li> ゴールリストはすべて満たしてから次のステップに行く </li>
<li> その時点のゴール状態を満たすためのサブゴールの生成 </li>
<li> ゴール状態に関係のある状態が先に来るように場の状態をソート </li>
<li> ユーザが予想しているような最終状況になるようにゴール状態を調整、およびプランニングが最適にできるようにゴール状態を並び替え </li>
</ol><br>
といったことを実装した。
</ul>
<br>

<h3>実装の説明</h3>
<!--
 どう実装したか，ソースコードを詳細に説明する．
 特に重要な箇所はレポートにペーストして説明する．
-->
<p>
  実装したプログラムに関して，競合戦略解消のために行ったそれぞれの項目について説明をしていく。
</p>
<br>
<p>
  1.について：
</p>

<ul>
これは、ゴール状態が現在の状況にある場合、その数をステップごとにカウント(変数checkGoalCountsの該当箇所をインクリメント)し、そのステップにおけるゴールリストの要素数と同じになったらそのステップを終了させることで実現した。また、あるゴール状態をみたすためにプランニングを再帰的にプランニングを開始した場合、カウントをリセットし、毎回確認をさせることで確実に状況が満たされるようにしてある。<br><br>
</ul>

<p>
2.について：
</p>
<ul>
これは各ゴール状態を調べるときに、Planner::makeSubGoal(String, Vector, Vector, ArrayList)に通すことで実現している。
Planner::makeSubGoalは場の状況にゴール状態がないという仮定の下でサブゴールの自動的に生成し、それを第４引数のArrayListに順に格納している。サブゴールを作成することで目標のオブジェクトの上に積まれているオブジェクトを不適切な位置に動かして、それが原因で無限ループに陥ってしまうのを防ぐことが出来る。具体的な実装については、まずゴール状態の中では下にくるオブジェクトに対して"clear -"が存在しているかを確認し、ない場合はその状況においてそのオブジェクトの上に載っているオブジェクトに対して"ontable -"をサブゴールとして生成しリストの先頭に格納。さらにそのオブジェクトに対しても同様に状況の確認を行う。次にゴール状態の中では上に来るオブジェクトに対しても同様に処理を行う。リストに格納する要素がない場合はそのまま渡された第一引数を返し、見つかった場合はリストの先頭を返す。以下はPlanner::makeSubGoalのソースである。

<!--
  ソースコードをはりつける時は <pre> タグを使う
  class="brush: java" でシンタックスハイライトする
  重要な部分のみを貼り付ければ良い
-->
<pre class="brush: java">
private String makeSubGoal(String theGoal, Vector goalList, Vector stateList, ArrayList<String> subGoalList)
	{
		//stateList内にはtheGoalはないと仮定
		String goal = theGoal;
		StringTokenizer tokens = new StringTokenizer(goal);
		String firstObject = tokens.nextToken();
		String lastObject;

		if(firstObject.equals("ontable") || tokens.nextToken().equals("on"))
		{
			lastObject = tokens.nextToken();
		}
		else
		{
			return goal;
		}

		if(!stateList.contains("clear " + lastObject))
		{
			for(int i = 0; i < stateList.size(); ++i)
			{
				String state = (String)stateList.get(i);
				if(state.indexOf("on " + lastObject) != -1)
				{
					StringTokenizer stateTokens = new StringTokenizer(state);
					String obj = stateTokens.nextToken();
					goal = "ontable " + obj;
					lastObject = obj;
					subGoalList.add(0, goal);
					i = -1;
				}
			}
		}

		if(!firstObject.equals("ontable") && !stateList.contains("clear " + firstObject))
		{
			for(int i = 0; i < stateList.size(); ++i)
			{
				String state = (String)stateList.get(i);
				if(state.indexOf("on " + firstObject) != -1)
				{
					StringTokenizer stateTokens = new StringTokenizer(state);
					String obj = stateTokens.nextToken();
					goal = "ontable " + obj;
					firstObject = obj;
					subGoalList.add(0, goal);
					i = -1;
				}
			}
		}

		if(subGoalList.size() != 0)
			return subGoalList.get(0);

		return goal;
	}
</pre>

また、ここで生成されたサブゴールは本来のゴールリストには格納せず、リスト内の要素分のプランニングを順次行ってから本来のゴールリストのプランニングに移るように設計している。
<br><br>
</ul>
<p>
3.について：
</p>
<ul>
これは単純にゴール状態に登場しているオブジェクトが使用されている場の状態をリストの前のほうに持っていく処理を行っている。
こうすることで、目標状態を達成しやすいような変数束縛がされるようにすることが出来る。実際の処理はPlanner::alignStateList(String, Vector)で行っている。以下は実際のコードである。

<pre class="brush: java">
	private Vector alignStateList(String goal, Vector stateList)
	{
		StringTokenizer tokens = new StringTokenizer(goal);
		Vector priorityStateList = new Vector();

		while(tokens.hasMoreTokens())
		{
			String token = tokens.nextToken();

			if(!token.equals("on") && !tokens.equals("ontable"))
			{
				for(int index = 0, delete = 0; index - delete < stateList.size(); ++index)
				{
					String state = (String)stateList.get(index - delete);
					StringTokenizer stateTokens = new StringTokenizer(state);
					while(stateTokens.hasMoreTokens())
					{
						if(stateTokens.nextToken().equals(token))
						{
							stateList.remove(state);
							priorityStateList.add(state);
							++delete;
							break;
						}
					}
				}
			}
		}

		stateList.addAll(0, priorityStateList);
		return stateList;
	}
</pre>
<br>
</ul>

<p>
 4.について：
</p>
<ul>これらはPlanner::alignGoalList(Vector)で実装しており、
 受け取った引数の内部の状態を下のほうから順に並び、かつ関係性があるものはまとまって
 並ぶように処理をしている。こうすることで、例えば上の状態からそろえようとすると、無駄にどかそうとする
動作がどうしても入ってきてしまい、それが無駄な探索につながるので、それを防ぐことが出来る。以下がそれを実装している部分のコードである。

<pre class="brush: java">
private Vector alignGoalList(Vector goalList)
	{
		Vector newGoalList = new Vector();
		ArrayList<ArrayList<String>> allObjects = new ArrayList<ArrayList<String>>();

		for(int i = 0; i < goalList.size(); ++i)
		{
			StringTokenizer tokens1 = new StringTokenizer((String)goalList.get(i));
			String firstObject1 = "";
			String lastObject1 = "";
			String goal1 = (String)goalList.get(i);
			
			if(newGoalList.size() == 0)
			{
				newGoalList.add(goal1);
				continue;
			}

			if(tokens1.hasMoreTokens())
				firstObject1 = tokens1.nextToken();
			if(firstObject1.equals("clear") || firstObject1.equals("ontable"))
			{
				goalList.set(i, "ontable " + tokens1.nextToken());
				newGoalList.add(goal1);
				continue;
			}
			if(tokens1.hasMoreTokens() && !tokens1.nextToken().equals("on"))
				continue;
			if(tokens1.hasMoreTokens())
			{
				lastObject1 = tokens1.nextToken();
			}
			else
				continue;

			for(int j = 0; j < newGoalList.size(); ++j)
			{
				String goal2 = (String)newGoalList.get(j);
				StringTokenizer tokens2 = new StringTokenizer(goal2);
				String firstObject2 = tokens2.nextToken();
				String lastObject2;
				
				if(tokens2.hasMoreElements() && tokens2.nextElement().equals("on"))
				{
					lastObject2 = tokens2.nextToken();
				}
				else
				{
					continue;
				}

				if(firstObject1.equals(lastObject2))
				{
					newGoalList.add(j, goal1);
					break;
				}
				else if(lastObject1.equals(firstObject2))
				{
					newGoalList.add(j+1, goal1);
				}
			}
		}

		String temp = "";
		
		for(int i = 0, j = 0; i < goalList.size(); ++i)
		{
			String lowerObj = "";
			String topObj = "";

			StringTokenizer tokens = new StringTokenizer((String)goalList.get(i));
			topObj = tokens.nextToken();
			if(!tokens.hasMoreTokens() || !tokens.nextToken().equals("on"))
			{
				continue;
			}
			lowerObj = tokens.nextToken();

			String goal = "ontable " + lowerObj;

			if(!temp.equals(lowerObj) && !goalList.contains(goal))
			{
				goalList.add(i, goal);
			}

			temp = topObj;
		}

		return newGoalList;
	}
</pre>
</ul>
<br>

<h3>実行例</h3>
<!-- 実行例を示す．PNGやGIF等の絵を張っても良い．-->
<ul>
  <li> 初期状態:
<ul>  
{clear A, A on B, clear C, C on D, ontable B, ontable D, handEmpty}
</ul>
  <li> ゴール状態:
<ul>
{D on C, C on B, B on A}
</ul>
</ul>
<br>
<p>
の下で実行した結果、以下のようなプランニングが行われた。<br><br>
</p>
<ul>
<pre>
remove A from on top B
put A down on the table
pick up B from the table
Place B on A
remove C from on top D
put C down on the table
pick up C from the table
Place C on B
pick up D from the table
Place D on C
</pre>
</ul>

<!-- ------------------------------------------------------------------------------------------------------------------- -->
<h2>考察</h2>
<ul>
今回は、色や形といった抽象的な概念を用いたプランニングはあまりやることができなかったが、
そういう概念がこのプログラムの中に入れ込まれると、現状ではほぼ最適化できてはいるものの、
最小手数がでなかったり、ましてや無限ループに陥ることも考えられるかもしれない。

また、競合戦略を解決するために用いた手法でどれだけよくなっているのかを実際に比較してみた。<br><br>
比較したのは、
<ol>
<li> 完成プログラム
<li> ゴールリストの並び替えを最初にやらない
<li> 場の状態の並び替えをやらない
<li> サブゴールの生成をやらない
</ol>
<br>
処理時間と結果の手数をそれぞれ以下の状態で計測してみる

<ul>
  <li> 初期状態:
<ul>  
{B on A, C on B, clear C, ontable A, handEmpty}
</ul>
  <li> ゴール状態:
<ul>
{A on B, B on C}
</ul>
</ul>
<br>
その結果、以下のようになった。

<table border="1" align="center">
<caption>実験結果</caption>
<tr>
<th>状態</th><th>処理時間</th><th>手数</th>
</tr>
<tr>
<td align="right">1</td><td align="right">39ms</td><td align="right">8</td>
</tr>
<tr>
<td align="right">2</td><td align="right">83ms</td><td align="right">16</td>
</tr>
<tr>
<td align="right">3</td><td align="right">45ms</td><td align="right">8</td>
</tr>
<tr>
<td align="right">4</td><td align="right">StackOverflow</td><td align="right">-</td>
</tr>
</table>
<br>
この結果から、たしかに早くなっているのがわかる。<br>
<br>
ただ、実験結果はこうなったものの、プログラムを組んだ僕目線からもまだまだ無駄な処理をしている箇所が
あるように見えるので、その辺はもうちょっとチューニングのしどころなのだろう。
</ul>

<!-- ------------------------------------------------------------------------------------------------------------------- -->

<hr>


<h2>感想</h2>
<!-- 感想を書く．-->
<!-- 例: 〜が面白かった，〜がわからなかった，〜を作ってみたい，講義・演習に関する要望，など．-->
<ul>
  プランニングを応用させてスライドパズルを作成するプログラムは僕も手伝ってはいたが、作り始めて
割と序盤の段階で、「これはプランニングには向いてない問題なのでは？」と思い始めていた節もあったのだが、
できそうな気はしていたので完成できなかったのは残念だった。ただ、これから問題設定などをしていく機会は
僕にもあると思うので、いい経験にはなったのかなとも思った。
</ul>

</body>
</html>
