<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">

  <!--
   デフォルトのスタイル
   より見やすく変更しても良い
  -->
  <link rel="stylesheet" href="default.css"/>

  <!--
    SyntaxHighlighter 3.0.83 (http://alexgorbatchev.com/SyntaxHighlighter/)
    Java のコードを読みやすくする
  -->
  <link rel="stylesheet" href="shCore.css"/>
  <link rel="stylesheet" href="shThemeDjango.css"/>
  <script src="shCore.js"></script>
  <script src="shBrushJava.js"></script>
  <script>SyntaxHighlighter.all();</script>

  <!--
    目次を動的に生成する
  -->
  <script src="outliner.js"></script>
  <script>
    window.addEventListener('load', function() {
      // 第一引数: アウトライン対象の要素のセレクタ，第二引数: アウトラインを格納する要素のセレクタ．
      new TOutliner('h2', '#outline');
    });
  </script>

  <title>知能プログラミング演習II レポート</title>
</head>

<body>
<header>
  <!-- グループ番号・学籍番号・名前を書く．-->
  <h1>グループ4 27115126 長谷川 達也</h1>

  <!-- 目次生成用 -->
  <nav id="outline"></nav>
</header>

<h2>グループ</h2>
グループ作成書類: <a href="../Grep7/index.html">Grep7</a><br>
メンバーと役割分担: 
<ul>
<li>佐藤 嵩晟 27115064: 課題7-3 GUI実装担当
<li>塩谷 昂平 27115069: 課題7-1 考察担当
<li>瀬戸口 大貴 27115085: 課題7-4 実装担当, グループ作成資料担当
<li>長谷川 達也 27115126: 課題7-2 実装担当
</ul>

<h2>ソースファイル</h2>
<ul>
  <li><a href="../../Planing/src/ColorAndForm.java">ColorAndForm.java(課題7-4)</a>
  <li><a href="../../Planing/src/FileLoading.java">FileLoading.java(ファイル読み込み)</a>
  <li><a href="../../Planing/src/GraphViz.java">GraphViz.java(グラフィック)</a>
  <li><a href="../../Planing/src/Planner.java">Planner.java(プランニングのベースプログラム)</a>
  <li><a href="../../Planing/src/PlannerGUI.java">PlannerGUI.java(課題7-3)</a>

    <!-- 実装・変更したソースファイルへのリンク．修正する． -->
    <!-- ※ リンクは絶対パスに変更せず，上記のような相対パスのままで！ -->
</ul>

<hr>

<h2>課題7-2</h2>
<!-- 課題を書く．-->
教科書のプログラムでは，オペレータ間の競合解消戦略としてランダムなオペレータ選択を採用している．
これを，効果的な競合解消戦略に改良すべく考察し，実装せよ．
改良の結果，性能がどの程度向上したかを定量的に（つまり数字で）示すこと．<br>
<br>

<h3>独自仕様の説明</h3>

  独自仕様として、ゴール状態がおかしな書き方がされても対応できるようにした。<br>
  <br>
  たとえば、ゴール状態を"A on B on C"という風にしても、内部的には"B on C", "A on B"
  と分解された状態で認識されるような実装方法をとった。<br>
  <br>

<h3>プログラムの変更箇所</h3>

  競合戦略を効果的にするために、以下のメソッドを編集および追加をした。<br>
  <br>
  Planner::planning：
  <ol>
    プランニングを実際に行う関数。後ろ向き推論においてひとつ前のオペレータを
    引数として渡せるようにした。
  </ol>
  Planner::planningAGoal:
  <ol>
    プランニングにおいて、ゴール状態を一つずつ検討する関数。Planner::planning
    と同様にオペレータを引数に渡せるようにした。
  </ol>
  Planner::alignGoalList:
  <ol>
    ゴールリストをある程度都合のいいように並び替えや分解を行う関数。
  </ol>
  Planner::initOperator:
  <ol>
    プランニング前に、オペレータ群を初期化する関数。オペレータ間の依存関係を
    追加する処理を追加した。
  </ol>
  Operator::GetPairedOperator:
  <ol>
    オペレータに依存している別のオペレータのリストを返す関数。
  </ol>
  Operator::addPairedOperator:
  <ol>
    引数に渡されたオペレータを依存しているオペレータのリストに追加する関数。
  </ol>
  Operator::getIsRelatedNextOperator:
  <ol>
    依存関係があるオペレータがひとつ前に来ている場合に、チェックする必要がある
    のかをフラグに事前知識として与えておいて、それを返す関数。
  </ol>
  Unify::unifyToken:
  <ol>
    もともとunifyの引数が少ないものだったのだが、名前を変えたもの。比較が必要な
    場合に、変数束縛がすべて同じでないかを比較する処理を追加した。
  </ol>
  Unify::tokenMatching:
  <ol>
    それぞれのトークンでマッチングを行う関数。片方が変数の場合に別で定義したvarMatching
    を呼ぶように処理を変更した。
  </ol>
  Unify::varMatching:
  <ol>
    それぞれの変数に束縛を行う関数。片方が変数の場合は、引数を増やしたものを呼び、
    その内部では同じステップの変数割り当てで別の変数なのにかぶっている場合にfalse
    を返すように処理を追加した。
  </ol><br>
  
  <h3> 実装の説明 </h3>
  今回、実装した点を大まかにまとめると、以下のようになる。
  <ol>
    <li> 変数束縛の別の変数なのに同じ値が入るバグの修正 </li>
    <li> ゴール状態の編集 </li>
    <li> 依存関係があるオペレータを優先的に探索するように編集 </li>
    <li> 一段階前のオペレータに依存関係があり、比較する必要があるならば、変数束縛をチェックする </li>
  </ol>
  <br>
  1.に関しては、
<!-- -------------------------------------------------------------------------------------------------- -->
<h2>考察</h2>
<!--
 考察を書く．PNGやGIF等の絵を張っても良い．
 例: 自分で工夫して解決した点，その解決手法，なぜそうしたのか，その手法の素晴らしさ，上手くいかなかった点，なぜ上手くいかなかったのか，など．
 例: 今回はできなかったが，更に〜の機能を追加すべきである．なぜなら，...
-->


<hr>


<h2>感想</h2>
<!-- 感想を書く．-->
<!-- 例: 〜が面白かった，〜がわからなかった，〜を作ってみたい，講義・演習に関する要望，など．-->


</body>
</html>
